# 进程互斥的硬件实现方法
## 中断屏蔽方法
- 关中断：关中断后即不允许当前进程被中断，也必然不会发生进程切换
- 开中断：直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理及并访问临界区
### 优点
简单、高效
### 缺点
不适用于多处理机，只适用于操作系统内核进程，不适用于用户进程(开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险)，权限非常大，特权指令

比如，一个处理器A开始访问某一个临界区，但另一个处理器B也可能会访问这个临界区，就有可能2个处理器都访问这段临界区，还是有一定的危险存在的。所以不适用于多处理机。
## TestAndSet指令(Ts指令/TSL指令)
TSL指令是用硬件来实现的，执行的过程不允许被中断，只能一气呵成。
![](https://files.mdnice.com/user/8332/8ee31a2c-bd36-4fed-93d0-8ef148f31f62.png)
- 若刚开始为false，则TSL返回的old值为false。while循环条件不满足，直接跳过循环，进入临界区。
- 若刚开始为true，则执行TLS后old返回的值为true，while循环条件满足，会一致循环，直到当前访问临界区的进程在退出区进行“解锁”。

相比软件的实现方法，TSL指令把上锁和检查操作用硬件的方式编程了一气呵成的原子操作。
### 优点
实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞，适用于多处理机环境

### 缺点
不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。

**底层，是运用物理的一块寄存器在存储lock的值。**

## Swap指令(XCHG指令)
有的地方也叫Exchange指令，Swap指令用硬件实现的，执行的过程不允许被中断，只能一气呵成。
![](https://files.mdnice.com/user/8332/913fd48a-7b6a-4962-aef5-59af5b6e95ed.png)
逻辑上看来Swap和TSL并无太大区别，都是先记录下此时临界区是否已经被上锁(记录在old变量上)，再将上锁标记lock设置为true，最后检查old，如果old为false，则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。

### 优点
实现简单，无需向软件件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理环境

### 缺点
不满足让权等待原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”




![](https://files.mdnice.com/user/8332/25e6cbd2-2cb5-4b33-9f9b-3bf67772e520.png)


