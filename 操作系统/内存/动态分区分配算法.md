# 动态分区分配算法

>在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪一个分区进行分配？

## 动态分区算法
### 首次适应算法：
每次都从**低地址开始查找**，找到第一个能满足大小的空闲分区。


**如何实现**：空闲分区以地址递增的次序排列，每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。
  
![](https://files.mdnice.com/user/8332/d43c0ca3-f362-4b40-806a-2b2f4efc3668.png)

**优点：** 首次适应算法每次都要从头查找，每次都需要检索低地址的小分区，但是这种规则也决定了当低地址部分有跟小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来


### 最佳适应算法
由于动态分区分配是一种连续分配的方式，为各进程分配的空间必须是连续的一整片区域，因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多的留下大片地空闲区，即优先使用更小的空闲区。

**如何实现**：空闲分区**按容量递增次序链接**。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。

**缺点：** 每次都选最小的分区进行分配，会留下越来越多的、很小的、很难利用的内存块，因此这种方法**会产生很多的外部碎片**。
  
![](https://files.mdnice.com/user/8332/6e1c6574-fbda-440a-8453-8a084522c904.png)

### 最坏适应算法
又称最大适应算法，为了解决最佳适应算法的问题--即留下了太多的难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。

**如何实现**：空闲分区**按容量递减次序链接**，每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。
**缺点：** 每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会**导致较大的连续空闲区被迅速用完**。如果用完之后有“大进程”到达，就没有内存分区可用了。



### 邻近适应算法
首次适应算法每次都要从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。

**如何实现**：空闲分区**以地址递增的顺序排列(可排成一个循环链表)**，每次分区内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。

**缺点：** 邻近适应算法的规则可能会导致无论高地址、低地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用(最大适应算法的缺点)

![](https://files.mdnice.com/user/8332/c7ac23f8-437f-4ba0-b357-8ab7c0867ce1.png)






![](https://files.mdnice.com/user/8332/dbd3cf3e-90cd-4e50-9a96-dc0fffe43e7c.png)

