# volatile

一种轻量级的同步机制，他有两个特性：
- 保证所有共享变量对所有线程的可见性
- 禁止指令重排序


## 缓存一致性

由于CPU的指令速度远超内存的存取速度。所以计算机系统中加入了一层读写速度尽可能接近处理器运算速度的高速缓存，来作为内存于处理器之间的缓冲。

新的问题出现：缓存一致性

缓存行问题。

缓存行 cache line 64个字节

MESI 
读取一整个缓存行，某一个线程改过了，会通知其他CPU，我被改掉了，你需要在去内存中改，使用了缓存一致性协议，



缓存行的四种状态：
- Modified 修改
- Exclusive
- shared 共享
- invalid 失效

##
![](https://files.mdnice.com/user/8332/048962b1-8d88-4809-865f-6655e53b666a.png)



## lock汇编指令
用于多处理器中执行指令时对共享内存的独占使用，它的作用时能够将当前处理器对应的缓存的内容刷新到主存，并使其他处理器对应的缓存失效，另外还提供了有序指令无法越过这个内存屏障的作用



## 可见性问题
Java的内存模型：描述了java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量，存储到内存和内存中读取变量这样的底层细节。

### 规定

JMM定义了共享内存系统中多线程读写操作行为的规范，来屏蔽各种硬件和操作系统的内存访问差异，共享变量(实例变量和类变量)都存储与主内存，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。


- 每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。


- 线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量。


- 不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的**传递**需要通过**主内存**中转来完成。


## 加锁可以避免
加锁，清空线程的本地内存，重新从主内存中读取，拷贝到工作区，副本。。。
释放了，在把更改的值刷新会主内存。
并且，加锁获取不到锁的线程会一直等待，所以变量的值一直是新的。


## volatile做了什么？

每个线程操作数据的时候会把数据从主内存读取到自己的工作内存，如果他操作了数据并且写回了，他其他已经读取的线程的变量副本就会失效了，需要都数据进行操作又要再次去主内存中读取了。

volatile保证不同线程对共享变量操作的可见性，也就是说一个线程修改了volatile修饰的变量，当修改写回主内存时，另外一个线程立即看到最新的值。


## 重排序
cpu乱序执行，就是为了提高效率。
比如烧水的时候，可以做其他事情

两条指令没有因果关系的情况下，在第一条指令往内存读取数据的时候，可能第二条指令已经在执行了


两条指令指令加了一层墙，谁都过不来



## as if serial
不管如何重排序，单线程执行结果不会改变

因为只是对无因果关系的进行重排序，并且单线程，所以不论指令如何重排，都不会影响最终的结果

## happends-before


## volatile不能保证复合操作的原子性
如果num是个共享变量，那么num++不是原子性的操作，而是复合操作。这个操作分为三步：1.读取；2.加一；3.赋值。

因此，在多线程环境下，有可能线程A将num读取到本地内存中，此时其他线程可能已经将num增大了很多，线程A依然对过期的num进行自加，重新写到主存中，最终导致了num的结果小于预期。


https://blog.csdn.net/u011212394/article/details/82154790?utm_medium=distribute.pc_relevant_download.none-task-blog-baidujs-1.nonecase&depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-baidujs-1.nonecase



![](https://files.mdnice.com/user/8332/ad9900f4-a7af-4776-96e8-ea4f8693ac83.png)



![](https://files.mdnice.com/user/8332/fca626f2-c564-49f1-b111-dd714292a914.png)
