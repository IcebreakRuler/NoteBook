## i++操作
假设变量初始值i=0，如果两个线程同时需要对一个变量i+1, 两个线程都读取到i的值为0到自己的工作内存当中，然后执行加1操作，由于变量被volatile修饰了，需要将计算结果写回到主存，但是写回去的时候需要对缓存行加锁，但只会有一个加锁失败，加锁成功的CPU缓存行状态变为M，即MESI协议中的修改状态，这时会通知另外一个线程数据失效变为I状态，这个线程的i+1的运算结果被丢弃了，所以volatile不能保证原子性。


内存屏障是线程安全的,但是内存屏障之前的指令并不是.在某一时刻线程1将i的值load取出来，放置到cpu缓存中，然后再将此值放置到寄存器A中，然后A中的值自增1（寄存器A中保存的是中间值，没有直接修改i，因此其他线程并不会获取到这个自增1的值）。如果在此时线程2也执行同样的操作，获取值i==10,自增1变为11，然后马上刷入主内存。此时由于线程2修改了i的值，实时的线程1中的i==10的值缓存失效，重新从主内存中读取，变为11。接下来线程1恢复。将自增过后的A寄存器值11赋值给cpu缓存i。这样就出现了线程安全问题。




简单的说，修改volatile变量分为四步：

1）读取volatile变量到local

2）修改变量值

3）local值写回

4）插入内存屏障，即lock指令，让其他线程可见