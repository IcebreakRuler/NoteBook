# Synchronized
先说它的一些性质
- 可重入性

锁对象的时候有一个计数器

- 不可中断性

一个线程获取锁之后，另外一个线程处于阻塞或者等待状态，前一个不释放，后一个也一直会阻塞或者等待，不可以被中断
- 原子性


一个可重入锁，可以用来修饰代码块，普通方法，静态方法。
修饰代码块时，可以传入普通对象或者类对象，当传入普通对象时，它的一个范围就针对这个使用这个对象，如果是类对象，那么这个类所有的对象都会被同步访问。

普通方法，锁的只是对象

静态方法，锁的是类对象，或者普通对象


反编译 有一个monitor对象，
锁对象里有一个owner 等待队列  阻塞队列
执行完monitorexit，计数器就减1，才可以被其他线程持有
## 实例对象
- markword  对象头
  - hashcode
  - 锁状态
  - 分代年龄
  - 
- kclasspoint  类型  压缩4个字节  不压缩8个字节
- m 实例数据
- padding 补齐
## 锁升级

无锁-》偏向锁-》轻量级锁-》重量级锁

## markword
- markword
![](https://files.mdnice.com/user/8332/84b84e8d-75ff-4b5e-a6e8-441f83dce51f.png)

## 偏向锁
1. java6中引入了偏向锁来做进一步优化，只有第一次使用CAS将线程第一次使用CAS将线程ID设置到对象的Mark Word头，之后发现这个线程ID时自己的就表示没有竞争，不用重新CAS。以后只要不发生竞争，这个对象就归该线程所有。



2. 偏向锁有延迟， 会延迟大概4秒钟左右
jvm启动过程，会有明确的存在线程竞争，所以默认不会打开偏向锁，
因为jvm虚拟机自己有一些默认启动的线程，里面有很多同步代码，这些同步代码启动时就知道肯定会有竞争，如果使用偏向锁，就会造成偏向锁不断进行锁撤销或者锁升级的操作，效率较低。而是直接使用自旋锁 jvm启动进程，所以默认情况启动时不会打开偏向锁，过一段时间再打开

上偏向锁，就是把markword中的线程id改成自己线程id的过程，

偏向锁不可重偏向，批量偏向 批量撤销
#### 为什么要引入偏向锁？
因为经过HotSpot的作者大量的研究发现，大多数时候是不存在锁竞争的，常常是一个线程多次获得同一个锁，因此如果每次都要竞争锁会增大很多没有必要付出的代价，为了降低获取锁的代价，才引入的偏向锁。
#### 批量重偏向
对象被多个线程访问，但是没有竞争，这是偏向了线程T1的对象，仍有机会重新偏向T2，重偏向会重置对象的ThreadID。
当撤销偏向锁阈值超过20次后，jvm会这样觉得，我是不是偏向错了，于是在给这些对象加锁时重新偏向至加锁线程。


#### 批量撤销
当撤销偏向锁阈值超过40次后，jvm会这样觉得，自己确实偏向错了，根本就不该这样偏向，于是整个类的所有对象都会变得不可偏向的，新建的对象也是不可偏向的。


偏向锁是改动那个对象头里的线程值
## 轻量级锁

轻量级锁，在当前线程的栈帧中里面有一个lock record 锁记录，使用cas替换markword中的对象头信息，并且修改状态为00，然后把lock record中的owner指向当前对象


如果有其他线程竞争，那么默认会自旋10次，如果拿到不锁，就进入锁升级，也就是重量级锁。在此之前修改锁的状态


当要释放这个锁时，会使用cas将mark word的值恢复给对象头

### 自选优化
自适应




## 锁消除
Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，经过逃逸分析，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间

## 锁粗化
![](https://files.mdnice.com/user/8332/7a58e723-cf22-4071-8fa4-980563456418.png)

