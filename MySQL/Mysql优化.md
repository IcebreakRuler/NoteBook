# 优化


## 一条sql语句执行慢的原因有哪些?

分情况，偶尔慢 还是一直慢

1. 第一种情况

数据库在刷新脏页

插入数据或者更新数据，数据库会在内存把对应字段更新了，这些更新的字段并不会马上同步持久化到磁盘中去，而是把这些更新的记录写入到 redo log 日志中去，等到空闲的时候，在通过 redo log 里的日记把最新的数据同步到磁盘中去。


redolog写满，容量有限，数据库很忙，一直更新，然后满了，那么需要停下手头的工作，将这些数据同步到磁盘中，这个时候我们sql语句就会很慢


内存不够用了，查询较多数据，此时很多数据都不在内存中，那么需要申请内存。  淘汰一部分内存数据页， 干净页直接释放，  脏页直接刷脏页


系统空闲，

mysql正常关闭，把内存的脏页都flush到磁盘上，直接从磁盘上读数据，启动速度会很快




2. 拿不到锁
可能其他事务占用了， 读取不到数据，

如果判断是否在等待锁，可以使用show processlist来看状态

<hr>

3. 一直很慢

3.1 字段没有索引，只能全表扫描

3.2字段有索引，但没用到，由于自己疏忽


3.3函数操作导致没有用到索引


3.4数据库选错索引

主键索引存放的值是整行字段的数据

非主键索引存放的值不是整行字段的数据，而是存放主键字段的值


比如这样一个语句， c>100 and c<10000

c字段有索引，但不是主键索引，所以查到之后，还要去查询主键索引，但系统并不一定走c这个字段上的索引，有可能会扫描全表

然后系统 就会以扫描行数越少进行选择，也就意味着io次数越少越好

如果通过c索引找，那么会走2次索引，而且并不清楚这之间的行数有多少行，如果整个表都符合，这个时候是全表扫描加上2次索引。，所以，系统会选择走全表扫描，不走索引




## Explain
这个关键字可以模拟优化器来执行sql查询语句
id

select_type 

table ：这一行数据是关于哪张表的

type：判断sql语句是否好和坏

system>const>eq_ref>ref>range>index>all
sytem：系统表

const: 比如通过一次索引就找到了，比如主键索引或者唯一索引，因为只匹配一行数据，所以很快找到。比如将主键置于where字段中，mysql就能将该查询转换为一个常量

eq_ref:唯一性索引扫描，常用于主键或着唯一索引，表中只有一条记录与之匹配

range：检索给定范围的行 between < > in 等，范围扫描索引比全表扫描要好

index:遍历索引树 ，从索引读取肯定比all快，索引文件比数据文件小

all：从硬盘中读取，全表扫描的
possible_keys:可能使用到的索引

key：实际使用了索引

key len：可以通过key_len计算 是否充分用到了索引

ref：显示索引的哪一列被使用了

rows：执行查询时必须检查的行数，越少越好

extra

using filesort  文件索引，没有用到索引（外部排序）

using temporary ：使用了临时表保存中间结果，常见于order  by group by  在对查询结果排序时使用临时表

using index ：表示相应的select操作中使用了覆盖索引，避免了表的数据行。

using where:使用了范围查询

using join buffer：使用了连接缓存


## 什么是覆盖索引？
索引就是高效找到行的一个方法，但是我们也可以使用索引找到一个列的数据。 比如使用联合索引 然后再select 查询字段中，与我们组合索引的顺序一致， 比如 name ,age的联合索引，那我们select字段直接使用name age按照顺序。简单来说就是一个索引包含了我们再select子句或者查询字段或者where条件中所有需要的字段叫做覆盖索引

不能使用select *


## 慢查询日志
默认不会开启，因为对性能有所影响
set global slow_query_log=1
show variables like '%slow_query_log%'

提供了一个工具mysqldumpslow


## show profile
mysql提供用来分析当前会话中语句执行的资源消耗情况，可以用于SQL的调优

默认保存最近15次的运行结果

默认关闭
show variables like 'profiling' 
show profiles; 查看sql执行结果

显示所有开销的信息

显示块IO相关开销

上下文切换相关开销
## 全局查询日志


## 一般性建议
1. 对于单键索引，尽量选择针对当前query过滤性更好的索引
2. 再选择组合索引的时候，当前query中过滤性最好的字段再索引顺序中，位置越靠前越好。避免过滤性好的索引失效
3. 选择组合索引时，尽量选择能够包含当前查询中的where子句更多的字段的索引
4. where高于having，能写在where限定的条件就不要去having限定了。



